# ðŸ”¸ init

-  **Creates a New Repository**: It initializes a new Git repository in the current directory. This means Git will start tracking changes to the files in this directory.

-  **Creates a `.git` Directory**: It sets up a `.git` directory in your project folder. This directory contains all the metadata and version history for your Git repository, including configuration files, hooks, and information about the commits.

-  **Prepares for Version Control**: After running `git init`, you can start tracking files, making commits, and using other Git commands to manage the version history of your project.

```bash
cd /path/to/your/project
git init
```

---

# ðŸ”¸add

 **Purpose**: The `git add` command is used to stage changes (modifications, new files, deletions) before committing them to the Git repository. This tells Git that you want to include the changes in the next commit.
  
### Common Usage:
1. **Stage a single file**:
   ```bash
   git add index.js
   ```

2. **Stage multiple specific files**:
   ```bash
   git add file1 file2
   ```

3. **Stage all changes in the working directory**:
   ```bash
   git add .
   ```
   This stages all modified and new files recursively from the current directory.

4. **Stage specific changes within a file (interactive mode)**:
   ```bash
   git add -p
   ```
   Allows you to selectively stage parts of a file, such as specific changes or hunks.

### Notes:
- **Staging area**: `git add` moves changes to the staging area, preparing them for a commit.
- **Undo staging**: If you accidentally stage a file, you can remove it from the staging area with:
   ```bash
   git reset <file-name>
   ```

# ðŸ”¸commit
**git commit** is used to save changes to the local repository. It captures a snapshot of the project's current state. 

### Key Points:
- **Staging Area**: Files must be added to the staging area using `git add` before committing.
- **Best Practices for Commit Messages**:
  - Use **imperative** mood (e.g., "Add login page" not "Added login page").
  - Keep the message **short** (50 chars or less for the summary).
  - Optionally, follow with a longer explanation after a blank line.
  
### Common Options:
- `-m`: Add a commit message inline (e.g., `git commit -m "message"`)
- `--amend`: Edit the last commit (useful for fixing mistakes)
- `--no-edit`: Amend without changing the commit message.

### Commit Types:
- **feat**: New feature
- **fix**: Bug fix
- **refactor**: Code restructuring without changing functionality
- **docs**: Documentation changes

### Example Workflow:
```bash
git add .
git commit -m "fix: resolve login issue"
```

# ðŸ”¸push

**git push** is used to upload local repository changes to a remote repository (e.g., GitHub, GitLab).

### Key Points:
- **Sends Commits**: Transfers your local commits to a remote branch.
- **Common Syntax**: 
  ```bash
  git push <remote> <branch>
  ```
  - Example: `git push origin main`

### Push Process:
1. **Commit Changes**: Ensure you have committed changes locally (`git commit`).
2. **Push to Remote**: Upload changes with `git push`.

### Common Options:
- `git push`: Push changes from the current branch to the associated remote branch.
- `-u`: Set the upstream branch for future `git push` without specifying the remote and branch.
  - Example: `git push -u origin main`
- `--force` or `-f`: Force push to overwrite remote history (use with caution).

### Example Workflow:
```bash
git add .
git commit -m "feat: add search functionality"
git push origin main
```





---
# ðŸ”¸pull

**`git pull`** = `git fetch` + `git merge`

1. **Purpose**:  
   The `git pull` command updates your local repository by fetching and merging changes from a remote repository into your current branch.

2. **Basic Syntax**:
   ```bash
   git pull <remote> <branch>
   ```
   - `remote`: The name of the remote repository (default is `origin`).
   - `branch`: The name of the branch you want to pull from (e.g., `main` or `master`).

3. **Example**:
   ```bash
   git pull origin main
   ```
   This command fetches changes from the `main` branch on the `origin` remote and merges them into the current branch.

4. **Fast-forward Merge**:
   If there are no conflicts, Git performs a fast-forward merge, updating your branch without creating a new commit.

5. **Handling Merge Conflicts**:
   If your local changes conflict with the remote, Git will pause and allow you to resolve the conflicts manually before completing the merge.

6. **Common Options**:
   - `--rebase`: Rebase your changes on top of the fetched branch, avoiding a merge commit.
     ```bash
     git pull --rebase
     ```

---

# ðŸ”¸status
Here's a short but informative study note on `git status` for Obsidian:

---


**`git status`**: Check the current state of your working directory and staging area.

1. **Purpose**:  
   The `git status` command provides information on:
   - Untracked files
   - Changes not yet staged
   - Changes staged for the next commit
   - Files that have been modified

2. **Basic Syntax**:
   ```bash
   git status
   ```

3. **Key Sections**:
   - **Untracked files**: Files not yet added to version control.
   - **Changes not staged for commit**: Modified files, but changes not yet added (`git add` required).
   - **Changes to be committed**: Files staged and ready to be committed.

4. **Example Output**:
   ```bash
   On branch main
   Your branch is up to date with 'origin/main'.
   
   Changes not staged for commit:
     (use "git add <file>..." to update what will be committed)
     (use "git restore <file>..." to discard changes in working directory)
           modified:   file1.txt
           modified:   file2.js
   
   Untracked files:
     (use "git add <file>..." to include in what will be committed)
           newfile.py
   ```

5. **Usefulness**:
   - Helps track changes before committing.
   - Detects untracked, modified, or staged files.

---

This note serves as a quick reference on the `git status` command while using Obsidian!
# ðŸ”¸diff
# ðŸ”¸log

# ðŸ”¸show
---
# ðŸ”¸reset
# ðŸ”¸branch
# ðŸ”¸checkout
# ðŸ”¸merge
# ðŸ”¸stash
---

